// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © unicorpusstocks

// note:
// I especially don't use for-loops in this file, due to it getting to unprecise. 
// Everything is calculated semi-individual to reduce errors and noise



//@version=5
indicator("Crypto Altcoins RSPS", max_bars_back = 100)


import Unicorpus/NormalizedIndicators/1 as L


//Getting values
get_data(string input) =>
    request.security(input, timeframe.period, close)

//Getting values
get_data(string input) =>
    request.security(input, timeframe.period, close)


//Symbols

//benchmark
usdt = get_data("CRYPTO:USDTUSD")
btc = get_data("BINANCE:BTCUSDT")

//assets - Crypto Altcoins
eth = get_data("BINANCE:ETHUSDT")
bnb = get_data("BINANCE:BNBUSDT")
xrp = get_data("BINANCE:XRPUSDT")
sol = get_data("BINANCE:SOLUSDT")
ada = get_data("BINANCE:ADAUSDT")
avax = get_data("BINANCE:AVAXUSDT")
dot = get_data("BINANCE:DOTUSDT")
matic = get_data("BINANCE:MATICUSDT")
link = get_data("BINANCE:LINKUSDT")
atom = get_data("BINANCE:ATOMUSDT")
near = get_data("BINANCE:NEARUSDT")
algo = get_data("BINANCE:ALGOUSDT")
vet = get_data("BINANCE:VETUSDT")
icp = get_data("BINANCE:ICPUSDT")
apt = get_data("BINANCE:APTUSDT")
arb = get_data("BINANCE:ARBUSDT")
op = get_data("BINANCE:OPUSDT")
sui = get_data("BINANCE:SUIUSDT")
inj = get_data("BINANCE:INJUSDT")
ftm = get_data("BINANCE:FTMUSDT")


//======================================================



get_rsps(asset) =>

    math.avg(nz(L.qqq_4d_cal(asset == eth ? eth : asset / eth)), nz(L.qqq_4d_cal(asset))) <= 0.1 ? -0.5 : math.avg(

        
         nz(L.qqq_4d_cal(asset == btc ? btc : asset / btc)),
         nz(L.qqq_4d_cal(asset == eth ? eth : asset / eth)),
         
         nz(L.qqq_4d_cal(asset == bnb ? bnb : asset / bnb)),
         nz(L.qqq_4d_cal(asset == xrp ? xrp : asset / xrp)),
        
         nz(L.qqq_4d_cal(asset == sol ? sol : asset / sol)),
         nz(L.qqq_4d_cal(asset == ada ? ada : asset / ada)),
         nz(L.qqq_4d_cal(asset == avax ? avax : asset / avax)),
         nz(L.qqq_4d_cal(asset == dot ? dot : asset / dot)),
         nz(L.qqq_4d_cal(asset == matic ? matic : asset / matic)),
         nz(L.qqq_4d_cal(asset == link ? link : asset / link)),
         nz(L.qqq_4d_cal(asset == atom ? atom : asset / atom)),
         nz(L.qqq_4d_cal(asset == near ? near : asset / near)),
         nz(L.qqq_4d_cal(asset == algo ? algo : asset / algo)),
         nz(L.qqq_4d_cal(asset == vet ? vet : asset / vet)),
         nz(L.qqq_4d_cal(asset == icp ? icp : asset / icp)),
         nz(L.qqq_4d_cal(asset == apt ? apt : asset / apt)),
         nz(L.qqq_4d_cal(asset == arb ? arb : asset / arb)),
         nz(L.qqq_4d_cal(asset == op ? op : asset / op)),
         nz(L.qqq_4d_cal(asset == sui ? sui : asset / sui)),
         nz(L.qqq_4d_cal(asset == inj ? inj : asset / inj)),
         nz(L.qqq_4d_cal(asset == ftm ? ftm : asset / ftm))
         )
      
filter(input)=>
     input >= 0 ? input : 0

//======================================================
//bools
plot_table = input.bool(true)

//=======================================================
//declaring arrays for tables

names = array.from(
     "eth", "btc",
     "bnb", "xrp", 
     "sol", "ada", 
     "avax", "dot",
     "matic", "link",
     "atom", "near", 
     "algo", "vet", "icp",
     "apt", "arb", "op",
     "sui", "inj", "ftm"
  
     )


values = array.from(

     get_rsps(eth), get_rsps(btc), 
     get_rsps(bnb), get_rsps(xrp), 
     get_rsps(sol), get_rsps(ada), 
     get_rsps(avax), get_rsps(dot),
     get_rsps(matic), get_rsps(link), 
     get_rsps(atom), get_rsps(near), get_rsps(algo), get_rsps(vet), get_rsps(icp),
     get_rsps(apt), get_rsps(arb), get_rsps(op), get_rsps(sui), get_rsps(inj), get_rsps(ftm)
     )

filtered_values = array.from(

     filter(values.get(0)), filter(values.get(1)), 
     filter(values.get(2)), filter(values.get(3)),
     filter(values.get(4)), filter(values.get(5)),
     filter(values.get(6)), filter(values.get(7)), filter(values.get(8)), 
     filter(values.get(9)), filter(values.get(10)),
     filter(values.get(11)), filter(values.get(12)), filter(values.get(13)), filter(values.get(14)),
     filter(values.get(15)), filter(values.get(16)), filter(values.get(17)), filter(values.get(18)),
     filter(values.get(19)), filter(values.get(20))

     )
max_alloc = filtered_values.sum()

alloc = array.from(

     filtered_values.get(0) / max_alloc, filtered_values.get(1) / max_alloc, 
     filtered_values.get(2) / max_alloc, filtered_values.get(3) / max_alloc, 
     filtered_values.get(4) / max_alloc, filtered_values.get(5) / max_alloc, 
     filtered_values.get(6) / max_alloc, filtered_values.get(7) / max_alloc, filtered_values.get(8) / max_alloc, 
     filtered_values.get(9) / max_alloc, filtered_values.get(10) / max_alloc,
     filtered_values.get(11) / max_alloc, filtered_values.get(12) / max_alloc, 
     filtered_values.get(13) / max_alloc, filtered_values.get(14) / max_alloc,
     filtered_values.get(15) / max_alloc, filtered_values.get(16) / max_alloc,
     filtered_values.get(17) / max_alloc, filtered_values.get(18) / max_alloc,
     filtered_values.get(19) / max_alloc, filtered_values.get(20) / max_alloc
     )

roc_alts = array.from(
     ta.roc(eth, 1) * alloc.get(0)[1], ta.roc(btc, 1) * alloc.get(1)[1], 
     ta.roc(bnb, 1) * alloc.get(2)[1], ta.roc(xrp, 1) * alloc.get(3)[1], 
     ta.roc(sol, 1) * alloc.get(4)[1], ta.roc(ada, 1) * alloc.get(5)[1], 
     ta.roc(avax, 1) * alloc.get(6)[1], ta.roc(dot, 1) * alloc.get(7)[1],
     ta.roc(matic, 1) * alloc.get(8)[1], ta.roc(link, 1) * alloc.get(9)[1],
     ta.roc(atom, 1) * alloc.get(10)[1], ta.roc(near, 1) * alloc.get(11)[1],
     ta.roc(algo, 1) * alloc.get(12)[1], ta.roc(vet, 1) * alloc.get(13)[1], ta.roc(icp, 1) * alloc.get(14)[1],
     ta.roc(apt, 1) * alloc.get(15)[1], ta.roc(arb, 1) * alloc.get(16)[1], ta.roc(op, 1) * alloc.get(17)[1],
     ta.roc(sui, 1) * alloc.get(18)[1], ta.roc(inj, 1) * alloc.get(19)[1], ta.roc(ftm, 1) * alloc.get(20)[1]
     )




//cash
use_cash = input.bool(false)
cash = input.int(100)



get_data2(string input) =>
    nz(L.deep_1d_cal(request.security(input, timeframe.period, close)))
get_data3(string input) =>
    nz(L.deep_1d_cal(request.security(input, timeframe.period, close[13] * -1)))




rsps = array.from(

     math.avg(
         //benchmark
  
         nz(L.deep_1d_cal(btc * -1)),
         nz(L.deep_1d_cal(eth * -1)),
         nz(L.deep_1d_cal(bnb * -1)),
         nz(L.deep_1d_cal(xrp * -1)),
         nz(L.deep_1d_cal(sol * -1)),
         nz(L.deep_1d_cal(ada * -1)),
         nz(L.deep_1d_cal(avax * -1)),
         nz(L.deep_1d_cal(dot * -1)),
         nz(L.deep_1d_cal(matic * -1)),
         nz(L.deep_1d_cal(link * -1)),
         nz(L.deep_1d_cal(atom * -1)),
         nz(L.deep_1d_cal(near * -1)),
         nz(L.deep_1d_cal(algo * -1)),
         nz(L.deep_1d_cal(vet * -1)),
         nz(L.deep_1d_cal(icp * -1)),
         nz(L.deep_1d_cal(apt * -1)),
         nz(L.deep_1d_cal(arb * -1)),
         nz(L.deep_1d_cal(op * -1)),
         nz(L.deep_1d_cal(sui * -1)),
         nz(L.deep_1d_cal(inj * -1)),
         nz(L.deep_1d_cal(ftm * -1))) * 0.75,
 

     math.avg(
         get_data3("USDWCU + EURWCU + CNYWCU+ JPYWCU"),
         math.avg(get_data3("T10Y2Y"),
             get_data3("BAMLH0A0HYM2 * -1")),
         get_data3("(USGD + USM2 + USCBBS) * USDWCU")) * 0.25


     )

//plots

majors_strength = rsps.sum() >= 0.2 ? 0 : filtered_values.avg()


color = color.rgb(212, 0, 0, 20)

f1 = plot(0, "midline", #ffffff, 2)
f2 = plot(majors_strength, "Majors tpi", color, 3)
fill(f1, f2, color)


col_out = majors_strength > 0 ? 1 : 5
plot(col_out, "color", display = display.none)


f3 = plot(0, "midline", #ffffff)
f4 = plot(rsps.sum() <= 0 ? 0 : rsps.sum() * 0.5, "TPI", color.navy, 2,plot.style_line,true)
fill(f3, f4, color.new(color.navy, 20))


summe = (filter(rsps.sum()) * 0.5 + majors_strength)

cash_alloc = filter(rsps.sum()) * 0.5 / summe

main_alloc = majors_strength / summe


// Robustify main_roc calculation and perf update
main_roc = nz(roc_alts.sum() * main_alloc, 0)

var float perf = 0.2
perf := perf * (1 + main_roc / 100)
plot(perf, "Portfolio Performance", color = cash_alloc >= majors_strength ? color.blue : color.red, linewidth=2, force_overlay = true)




//===================================================
//plot rsps table

//table
var crypto_table = table.new(position.bottom_left, 40, 40, na, na, na, na, na, true)

if plot_table


//header
    crypto_table.cell(0, 2, "Crypto Altcoins", text_color = #ffffff)
    crypto_table.merge_cells(0, 2, 2, 2)
    crypto_table.cell(0, 3, "Asset", text_color = #ffffff)
    crypto_table.cell(1, 3, "RSPS Value", text_color = #ffffff)
    crypto_table.cell(2, 3, " ", text_color = #000000)
    // Cash-Header hinzufügen, wenn benötigt
    if use_cash
        table.cell(crypto_table, 2, 3, "cash", text_color = #ffffff)
    else
        table.cell(crypto_table, 2, 3, " ", text_color = #ffffff)




//spacer
    crypto_table.cell(0, 1, "                ")
    crypto_table.cell(0, 12, "                ")


     //main table - jetzt mit Cash-Berechnungen in derselben Schleife
    for c = 0 to 19
        // Asset-Namen anzeigen
        table.cell(crypto_table, 0, c + 4, rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : names.get(c) : na, 
         bgcolor = na, text_color = rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : values.get(c) <= 0.1 ? color.gray : color.red : na)

        // Prozentuale Allokation anzeigen
        table.cell(crypto_table, 1, c + 4, rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : str.tostring(math.round(alloc.get(c) * main_alloc * 100, 2)) + "%" : na, 
         bgcolor = na, text_color = rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : values.get(c) <= 0.1 ? color.gray : color.red : na)

        // Cash-Wert berechnen und anzeigen, wenn aktiviert
        if use_cash
            float the_cash_plot = math.round(alloc.get(c) * main_alloc * cash, 2)
            table.cell(crypto_table, 2, c + 4, rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : str.tostring(the_cash_plot) : na, 
             bgcolor = na, text_color = rsps.sum() <= 0.2 ? values.get(c) <= -1 ? na :  values.get(c) <= 0.0 ? na : color.aqua : na)


    table.cell(crypto_table, 0, 24, "cash", 
             bgcolor = na,
             text_color = color.blue)

    // Prozentuale Allokation anzeigen
    table.cell(crypto_table, 1, 24, str.tostring(math.round(cash_alloc * 100, 2)) + "%", bgcolor = na, text_color =  color.blue)

    // Cash-Wert berechnen und anzeigen, wenn aktiviert
    if use_cash
        float the_cash_plot = math.round(cash_alloc * cash, 2),
        table.cell(crypto_table, 2, 24, str.tostring(the_cash_plot), text_color = color.blue)
